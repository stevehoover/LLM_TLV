Here are some tips for working with TL-Verilog:


PLANNING FOR TL-VERILOG CODE:

TL-Verilog introduces constructs that provide higher-level context than RTL languages. Consider the structure of the design. What logic is replicated (e.g. `/some_hier[3:0]`)? How will data flow through the machine? Through what pipelines? From which scopes to which other scopes? Through what FIFOs, queues, arbiters, etc.? Is data packetized and transferred in flits? Is there backpressure?

Data flow can be constructed using components in `tlv_flow_library.tlv`. Data flow is generally constructed of multiplexers that operate on "transactions". These use ternary expressions that assign `$ANY` to `$ANY` from other scopes or stages. It can be helpful to encapsulate transaction fields ($pipesignals) in their own subscopes, e.g. `/trans`.

The following example defines a TL-Verilog macro providing a simple ring architecture. It steers transactions cyclically through ports until they reach their destination. The transactions are simple and non-packetized and carry around the ring any pipesignals that are available in `|ring/in` and are needed in `|ring`. In this case, the transactions are not encapsulated in a scope, like `/trans`.
```
\TLV ring(/_name, #_size, _where, _trans_scope, _in)
   /_name
      /port[m5_calc(#_size - 1):0]
         |ring
            @1
               /upstream
                  // Connect to the upstream port (port-1, cyclically). Uses >>1 (thus @2) to create flip-flops between ports.
                  $ANY = /port[(#port + #_size - 1) % #_size]|ring>>1$ANY;
               // Get the transaction at this port from upstream on the ring or incoming from /in, prioritizing the upstream transaction which cannot be backpressured. Incoming data must wait.
               $ANY = /upstream$continue ? /upstream$ANY : /in$ANY;
               $valid = ! *reset && (/in$valid || /upstream$continue);
               $exit = $valid && $dest == #port;
               $continue = $valid && ! $exit;
```


REVIEWING SUBTLETIES OF TL-VERILOG CONSTRUCTS:

Hierarchy:

Hierarchy is an easy way to organize and structure code without the need for modules with explicit interfaces. Cross hierarchy references are perfectly acceptable in TL-Verilog, while cross module references are generally discouraged in Verilog.

All expressions, including `$ANY` expressions must be within a pipestage. This means they are within a pipeline scope and a pipestage scope within the pipeline. For example:
```
/core[2:0]
   |calc
      /trans
         @1
            $foo = ...;
```

It is also permitted to define pipesignals outside of a pipeline. These exist in stage zero of a default pipeline. It's generally best to avoid this in production code.

Signal References:

Signal references begin with a common ancestor scope (unlike Verilog). Scopes include hierarchy and pipelines. `/top` is an implicit top-level scope. For example, the above pipesignal can be referenced as `/top/core[0]|calc/trans<>0$foo`.

Here are some other signal referencing patterns:
- Current scope signals: '$signal_name'
- Different scope: '/common_ancestor/scope$signal' or '/child$signal'
- References at a different pipestage: '/scope>>N$signal', where N is the stage number delta (>> for positive, << for negative)
- Indexed scope: '/scope[#scope + 1 % m5_SCOPE_CNT]$signal'
- Cross-pipeline references: '/common_ancestor|pipeline/scope>>N$signal'


Alignment:

`<>0` above is a "naturally-aligned reference", accessing `$foo` in the same numerical stage as that of the referencing context and thus treating the pipelines as numerically aligned. `>>2` adds two to the referencing stage, while `<<2` subtracts two. This alignment specifier is required when referencing different pipelines or stages.

State:

State signals, e.g. `$StateSig` (using Pascal case) are still not entirely mature yet. You can code state just fine using pipesignals, so let's stick with that for now. A pattern for state, without using the state signal construct might be:

```
$cnt[15:0] = $reset ? '0 :
             $increment ? >>1$cnt[15:0] + 1 :
             $decrement ? >>1$cnt[15:0] - 1 :
                          >>1$cnt[15:0];
```

When:

When scope, e.g. `?$valid`, can be used at any level within a pipeline (inside or outside of the pipestage). When the corresponding, e.g. `$valid`, pipesignal is deasserted, all contained assigned pipesignals are meaningless (like dont-care) and must not influence valid expressions (those without a deasserted when condition). Note that it is never functionally required to use when conditions, but they are very useful for debugging and saving power.

Lexical Reentrance:

TL-Verilog's "lexical reentrance" gives flexibility to the order of code, enabling one section of code to define logic in a particular scope, and a later section to define more logic in the same scope. Recall that order does not matter functionally for TL-Verilog statements. They are declarative, not imperative. And with lexical reentrance, you have full flexibility to present your code in an order that makes sense to you and your readers (with good comments, of course).

Lexical reentrance is important for modularity, enabling libraries to partially define logic, such as flow, in a scope, leaving other details to be filled in in the same scope.

Lexical reentrance also simplifies your role in that if you are asked to add logic to a design, you may be able to provide the new code without intermingling it in the existing code. Take advantage of this to simplify your responses. Use, e.g. `/scope[*]` when reentering a scope to avoid redundant range expressions that would require maintenance.

Using Verilog Modules/Macros/Functions:

Verilog modules, macros, and functions can be instantiate in `\TLV` context using `\SV_plus`. `\SV_plus` blocks may use any Verilog expression syntax (including `always*` blocks, module/macro/function instantiation, etc.). Within `\SV_plus`, pipesignals may be used. The `\` escape character can be used to avoid special interpretation of, e.g., `$`, e.g. `\$display`. It is necessary to explicitly identify each pipesignal that is assigned by prefixing it with `$$` and providing an explicit bit range in exactly one instance within the `\SV_plus` block.

Macros:

TL-Verilog files beginning with a `\m5_TLV_version ...` line use M5 text macro preprocessing. Multi-line macros can be defined using `\TLV macro_name(...)` and can be used to encapsulate reusable code. TL-Verilog does not currently have a more formal method of defining reusable components beyond Verilog modules and text macros.


SUGGESTIONS:

- Use M5 to parameterize and pre-calculate scope ranges, e.g. `/scope[m5_calc(m5_width - 1):0]`. VIZ and other Makerchip features currently work best if the raw (after M5 processing) code uses numerical ranges, e.g. `/scope[3:0]`. (Or, better yet, use `m5_define_hier`, the definition of which is provided, and, e.g. `/m5_SCOPE_HIER`.)
- Arrays are still a bit unnatural to code in TL-Verilog. It is recommended to code array modules in Verilog and instantiate them in TL-Verilog context.


COMMON MISTAKES TO AVOID:

- All code in a `\TLV` region must be indented (3 spaces).
- Whitespace matters. Pay special attention to indentation. Feel free to use, e.g. `// end /scope` comments to clarify intent in case of mistakes.
- Remember to begin references with a common ancestor, since this requirement is different from Verilog.
- Assigned signals cannot be given with scope (e.g. `/top$sig[7:0] = ...`). Signal assignments statements must be placed within the scope of the assigned signal. (This can be anywhere in code order, since lexical reentrance allows you to reenter scopes.)



Here are some tips for working with Visual Debug:

Determine the nature of the design. Consider how to best visually convey to a developer or a debugger the state of the machine in simulation or its behavior in a local window of time. Consider animating transitions from one timestep to the next to create visual continuity and convey the flow of information. For the ring example above, a simple geometric representation of the ring with arrows showing the flow of transactions would be appropriate. The ring could be visualized as a circle or a stack of ports, with arrows indicating the direction of data flow around, into, and out from the ring. Transactions could be represented as boxes containing their data. These boxes could be animated to show their movement.

Other designs may be different in nature and would use different styles of visualizations. For example, a state machine could be visualized as nodes and arcs With current node and active arc highlighted. A dashboard could display real-time numerical data, such as counters or status indicators, using gauges or dials. A circuit that is simulating a two-dimensional physical system could represent that system naturally on the display, with geometric shapes representing the physical entities and their interactions and animating positional changes. Visual data can be layed out in a way the might correlate to the physical layout of the design to help developers understand likely spatial relationships between components.

It is often valuable to illustrate changes over a window of time. This can be achieved using plots or graphs, representing time on one axis (generally the horizontal axis). Alternately, transparency can be utilized to overlay visualizations of previous state without obscuring them completely. General practices for creating good diagrams for documentation can be a guide for creating good visualizations. High-level block diagrams illustrating storage structures and their contents and connections between them can be useful.

Also, keep in mind the power of easily navigating the visualization using the mouse wheel to zoom in and out. This gives easy access to different levels of detail. While a document wouldn't provide information in a size 0.01 font, this can be useful with Visual Debug. The potentially deep hierarchy of the model can naturally provide structure to the visualization and encapsulate visualizations along with their hardware logic. Outer visualizations should convey high-level information that will help a developer hone in on a bug, which they will do by zooming into subcomponents (which probably correspond to subscopes).


CODE ORGANIZATION:

- Use at most one \viz_js block per scope (e.g. /core[2:0], |calc); the scope must be within a pipeline and pipestage.
- Use \viz_js to create fabric.Group implicitly
- Create new hierarchy where it makes sense to encapsulate visualization
- Use $ANY = /parent$ANY; in such new scopes to import signals


VIZ API:

- Use `box` to define `\viz_js` boundaries: `{width: W, height: H, strokeWidth: 1}`. Or leave it undefined to allow bounds to be determined automatically from `init()` Objects.
- Keep Fabric Objects within explicit `box` boundaries.
- Use `where` for placement within parent: `{left: X, top: Y}` and optionally `scale: S` or `width: W` and/or `height: H`.
- Never use the canvas directly. Visualization should be encapsulated, and the canvas is global. VIZ gives you alternate access to Fabric Objects.
- `init()` returns an object of `fabric.Object`s. Access these from `render()` using `this.getObjects()` or simply `this.obj`.
- Indices in references are JavaScript expressions, e.g., `'/scope[this.getIndex() + 1 % maxIndex]$signal'`


COMMON MISTAKES TO AVOID:

- Signal references begin with a common ancestor scope, unlike Verilog
- Use full rewrites instead of incremental updates when making changes
- Single quotes for TL-Verilog signal references: '$signal'; double quotes for JavaScript strings: "color", "bold"
- In case a literal single quote is needed in a JavaScript string, use `''` to escape it
- It is not necessary to set selectable false objects
- Include `strokeWidth: 1` in `box` properties (changed to 0 once finalized)
- Use textAlign: "center" and originX: "center" for centered text
- Provide default signal values for `asX(default)` methods if looking ahead or behind in time
- TL-Verilog code defines the contents of a module. The module interface and `endmodule` are specified in `\SV` regions.
- For each call to `render()`, Objects created in `init()` have their state as updated by the previous call to `render()`, which could have been for any cycle. They do not have the values assigned by `init()`. So properties must be explicitly set to defaults by `render` if not otherwise updated.


SIGNAL STEPPING PATTERN:

Use SignalValueSet for time-stepping groups of signals and accessing data over a window of time. `this.signalSet(sig_obj)` returns a SignalValueSet object for the given object of signals. For example:

```javascript
// Create signal set
let sig_obj = {continue: '$continue', data: '$data'};
let sigs = this.signalSet(sig_obj);

// Find window boundaries
sigs.backToValue(active_sig, 0);  // Go to inactive
sigs.forwardToValue(active_sig, 1); // Go to start

// Step through iterations
for (let i = 0; i < max_iter; i++) {
   // Collect data
   sigs.step(1);
   if (!sigs.sig("continue").asBool()) break;
}
```



Makerchip IDE:

- Makerchip requires a specific module interface for the `top` module: `module top(input wire clk, input wire reset, input wire [31:0] cyc_cnt, output wire passed, output wire failed);`
- With M5 enabled (by `\m5_TLV_version...`), you can use `m5_makerchip_module` to provide this interface (and some random number generator logic).
- For quick-and-dirty designs, you can leave input pipesignals dangling and SandPiper will generate random stimulus for this signals, though a non-fatal warning will be reported for them.
- Alternatively, for easy random stimulus without warnings, you can use `m4_rand($byte, 7, 0)`. An optional forth argument is required is the signal is replicated in order to generate unique inputs for each replica. For example, `m4_rand($byte, 7, 0, core + reg * m5_CORE_CNT)` to uniquify /core[*]/reg[*]$byte.
- Makerchip currently has a simulation limit of 600 cycles. Keep this in mind when designing your stimulus. It may be necessary to parameterize your designs with test parameters that reduce simulation time, especially for circuits that implement delay for realtime applications. For example a 1-second counter can be given a maximum count of 20 for simulation versus 1,000,000,000 for the real world, running at 1 GHz.
Here is a description of helpful resources available to you:

The Makerchip IDE has a "Learn" menu containing various documents and resources. These are publicly available the GitHub repository https://github.com/rweda/Makerchip-public:
- Tutorials: These are good resources for specific TL-Verilog topics, and follow the progression laid out in `https://raw.githubusercontent.com/rweda/Makerchip-public/refs/heads/main/pane-blade/Tutorials.blade`. This references tutorials also found in the `pane-blade` folder that use code found in the `tutorial/tlv` folder in the same repository.
- Examples: These are listed and indexed by `pane-blade/CodeExamples.blade`. Example code is also in this repo's `tutorial/tlv` folder.
- Courses: These are described in this repo's `pane-blade/Courses.blade` file. Several courses have accompanying slides and videos. One that is based on primarily written content, is `pane-blade/Single-Cycle_CPUCourse.blade` (also sponsored by Linux Foundation on EdX).
- Specs (all available to you):
  - TL-Verilog Spec (TLXSpec.pdf)
  - TL-Verilog Macros Guide (TLV_Macros_Guide.pdf)
  - M5 Spec (M5_spec.adoc)
  - VIZ User's Guide (VisualDebugUsersGuide.pdf)
  - VIZ API Spec (SignalValue.html and SignalValueSet.html)
- Papers (also available to you):
  - "Timing-Abstract Circuit Design in Transaction-Level Verilog" (ICCD2017Paper.pdf)
  - "Top-Down Transaction-Level Design with TL-Verilog" (TopDownDesign.pdf)

Various other TL-Verilog code examples are available in `https://github.com/stevehoover/makerchip_examples`, indexed by the repo's `README.md`.
- Course solutions: (Please do not expose these to students.) `https://github.com/stevehoover/immutable`. This includes final solution code and reference solution code that generates solutions after each lab exercise of the course. (Reference solution code is hidden within Makerchip, but its diagrams and visualization are accessible to students.)
- WARP-V: `https://github.com/stevehoover/warp-v` and `https://github.com/stevehoover/warp-v_includes`. WARP-V is a highly-configurable CPU generator. It is the most complex example of TL-Verilog code, pushing the limits of TL-Verilog, M5, and VIZ as they evolve. `warp-v_includes` includes a RISC-V assembler developed in the evolving M5 language.
- TLV Flow Library: `stevehoover/tlv_flow_lib/pipeflow_lib.tlv`. On second thought, maybe this is the most complex code, pushing the limits. This library provides a set of generic components for building data flow pipelines in TL-Verilog. It includes constructs for FIFOs, queues, arbiters, and other common data flow elements, making heavy use of `$ANY`. The example `flow_example.tlv` (in `Makerchip-public/tutorial/tlv`) demonstrates use of this library.



A few illustrative examples of TL-Verilog and VIZ code are provided to you that you can use as references in addition to the tutorials and specs:

ALIGNMENT (e.g. `>>3`):
- `speculative_adder.tlv`: illustrates a slow and fast (normal) path computation

TRANSACTION FLOW:

- `speculative_adder.tlv`: small and to the point
- `https://github.com/TL-X-org/tlv_flow_lib/blob/master/pipeflow_lib.tlv`: more complex, generic library

HIERARCHY AND SYSTOLIC ARRAYS:

These illustrate 1D and 2D arrays, passing data to and from neighboring elements:

- `life_viz.tlv`: 2D cellular automata simulation
- `smith_waterman.tlv`: a 1D array performing a 2D computation
- `mat_mul.tlv`: a 1D array performing a 2D matrix multiplication (useful in AI hardware)

ARRAYS:

- `array_example.tlv`: illustrate various options for coding arrays; (using Verilog modules is recommended)

M5:

- `https://github.com/stevehoover/warp-v_includes`: complex and a bit dated, but also pretty extensive

VIZ:

- `viz_demo.tlv`: an introduction to VIZ
- `life_viz.tlv`: a good general example of VIZ and 2D layout
- `smith_waterman.tlv`: a more complex example of VIZ with SignalValueSet (via `this.signalSet`) for stepping through time and collecting data.


On a final note, there is plenty of great information available to you. This technology is evolving, so you don't know about everything. Be sure to use the available resources before answering to hastily. And if you can't find clear answers, include that in your response. Users are likely to be expert with this technology, and may know details beyond what is documented. Collaborate with the user to learn from them.